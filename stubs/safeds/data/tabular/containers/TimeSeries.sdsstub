package safeds.data.tabular.containers

from pathlib import Path
from safeds.data.image.containers import Image
from safeds.data.tabular.containers import Row
from safeds.data.tabular.containers import Table

/**
 * @param data The data.
 * @param targetName Name of the target column.
 * @param timeName Name of the time column
 * @param featureNames Names of the feature columns. If None, all columns except the target and time columns are used.
 */
class TimeSeries(
    data: Map<String, List<Any>>,
    @PythonName("target_name") targetName: String,
    @PythonName("time_name") timeName: String,
    @PythonName("feature_names") featureNames: List<String>? = null
) sub Table {
    /**
     * Get the target column of the time series.
     */
    attr target: Column<Any>
    /**
     * Get the feature columns of the time series.
     */
    attr features: Table
    /**
     * Get the time column of the time series.
     */
    attr time: Column<Any>

    /**
     * Read data from a CSV file into a table.
     *
     * @param path The path to the CSV file.
     * @param targetName The name of the target column
     * @param timeName The name of the time column
     * @param featureNames The name(s) of the column(s)
     *
     * @result table The time series created from the CSV file.
     */
    @Pure
    @PythonName("timeseries_from_csv_file")
    static fun timeseriesFromCsvFile(
        path: union<Path, String>,
        @PythonName("target_name") targetName: String,
        @PythonName("time_name") timeName: String,
        @PythonName("feature_names") featureNames: List<String>? = null
    ) -> table: TimeSeries

    /**
     * Return a new `TimeSeries` with the provided column attached at the end, as neither target nor feature column.
     *
     * The original time series is not modified.
     *
     * @param column The column to be added.
     *
     * @result result The time series with the column attached as neither target nor feature column.
     */
    @Pure
    @PythonName("add_column")
    fun addColumn(
        column: Column<Any>
    ) -> result: TimeSeries

    /**
     * Return a new `TimeSeries` with the provided column attached at the end, as a feature column.
     *
     * the original time series is not modified.
     *
     * @param column The column to be added.
     *
     * @result result The time series with the attached feature column.
     */
    @Pure
    @PythonName("add_column_as_feature")
    fun addColumnAsFeature(
        column: Column<Any>
    ) -> result: TimeSeries

    /**
     * Return a new `TimeSeries` with the provided columns attached at the end, as feature columns.
     *
     * The original time series is not modified.
     *
     * @param columns The columns to be added as features.
     *
     * @result result The time series with the attached feature columns.
     */
    @Pure
    @PythonName("add_columns_as_features")
    fun addColumnsAsFeatures(
        columns: union<List<Column<Any>>, Table>
    ) -> result: TimeSeries

    /**
     * Return a new `TimeSeries` with multiple added columns, as neither target nor feature columns.
     *
     * The original time series is not modified.
     *
     * @param columns The columns to be added.
     *
     * @result result A new time series combining the original table and the given columns as neither target nor feature columns.
     */
    @Pure
    @PythonName("add_columns")
    fun addColumns(
        columns: union<List<Column<Any>>, Table>
    ) -> result: TimeSeries

    /**
     * Return a new `TimeSeries` with an extra Row attached.
     *
     * The original time series is not modified.
     *
     * @param row The row to be added.
     *
     * @result table A new time series with the added row at the end.
     */
    @Pure
    @PythonName("add_row")
    fun addRow(
        row: Row
    ) -> table: TimeSeries

    /**
     * Return a new `TimeSeries` with multiple extra Rows attached.
     *
     * The original time series is not modified.
     *
     * @param rows The rows to be added.
     *
     * @result result A new time series which combines the original time series and the given rows.
     */
    @Pure
    @PythonName("add_rows")
    fun addRows(
        rows: union<List<Row>, Table>
    ) -> result: TimeSeries

    /**
     * Return a new `TimeSeries` containing only rows that match the given Callable (e.g. lambda function).
     *
     * The original time series is not modified.
     *
     * @param query A Callable that is applied to all rows.
     *
     * @result result A time series containing only the rows to match the query.
     */
    @Pure
    @PythonName("filter_rows")
    fun filterRows(
        query: (param1: Row) -> result1: Boolean
    ) -> result: TimeSeries

    /**
     * Return a new `TimeSeries` with only the given column(s).
     *
     * The original time series is not modified.
     *
     * @param columnNames A list containing the columns to be kept.
     *
     * @result table A time series containing only the given column(s).
     */
    @Pure
    @PythonName("keep_only_columns")
    fun keepOnlyColumns(
        @PythonName("column_names") columnNames: List<String>
    ) -> table: TimeSeries

    /**
     * Return a new `TimeSeries` with the given column(s) removed from the time series.
     *
     * The original time series is not modified.
     *
     * @param columnNames The names of all columns to be dropped.
     *
     * @result table A time series without the given columns.
     */
    @Pure
    @PythonName("remove_columns")
    fun removeColumns(
        @PythonName("column_names") columnNames: List<String>
    ) -> table: TimeSeries

    /**
     * Return a new `TimeSeries` with every column that misses values removed.
     *
     * The original time series is not modified.
     *
     * @result table A time series without the columns that contain missing values.
     */
    @Pure
    @PythonName("remove_columns_with_missing_values")
    fun removeColumnsWithMissingValues() -> table: TimeSeries

    /**
     * Return a new `TimeSeries` with every column that contains non-numerical values removed.
     *
     * The original time series is not modified.
     *
     * @result table A time series without the columns that contain non-numerical values.
     */
    @Pure
    @PythonName("remove_columns_with_non_numerical_values")
    fun removeColumnsWithNonNumericalValues() -> table: TimeSeries

    /**
     * Return a new `TimeSeries` with all row duplicates removed.
     *
     * The original time series is not modified.
     *
     * @result result The time series with the duplicate rows removed.
     */
    @Pure
    @PythonName("remove_duplicate_rows")
    fun removeDuplicateRows() -> result: TimeSeries

    /**
     * Return a new `TimeSeries` without the rows that contain missing values.
     *
     * The original time series is not modified.
     *
     * @result table A time series without the rows that contain missing values.
     */
    @Pure
    @PythonName("remove_rows_with_missing_values")
    fun removeRowsWithMissingValues() -> table: TimeSeries

    /**
     * Return a new `TimeSeries` with all rows that contain at least one outlier removed.
     *
     * We define an outlier as a value that has a distance of more than 3 standard deviations from the column mean.
     * Missing values are not considered outliers. They are also ignored during the calculation of the standard
     * deviation.
     *
     * The original time series is not modified.
     *
     * @result newTimeSeries A new time series without rows containing outliers.
     */
    @Pure
    @PythonName("remove_rows_with_outliers")
    fun removeRowsWithOutliers() -> newTimeSeries: TimeSeries

    /**
     * Return a new `TimeSeries` with a single column renamed.
     *
     * The original time series is not modified.
     *
     * @param oldName The old name of the column.
     * @param newName The new name of the column.
     *
     * @result table The time series with the renamed column.
     */
    @Pure
    @PythonName("rename_column")
    fun renameColumn(
        @PythonName("old_name") oldName: String,
        @PythonName("new_name") newName: String
    ) -> table: TimeSeries

    /**
     * Return a new `TimeSeries` with the specified old column replaced by a list of new columns.
     *
     * If the column to be replaced is the target or time column, it must be replaced by exactly one column. That column
     * becomes the new target or time column. If the column to be replaced is a feature column, the new columns that replace it
     * all become feature columns.
     *
     * The order of columns is kept. The original time series is not modified.
     *
     * @param oldColumnName The name of the column to be replaced.
     * @param newColumns The new columns replacing the old column.
     *
     * @result result A time series with the old column replaced by the new columns.
     */
    @Pure
    @PythonName("replace_column")
    fun replaceColumn(
        @PythonName("old_column_name") oldColumnName: String,
        @PythonName("new_columns") newColumns: List<Column<Any>>
    ) -> result: TimeSeries

    /**
     * Slice a part of the table into a new `TimeSeries`.
     *
     * The original time series is not modified.
     *
     * @param start The first index of the range to be copied into a new time series, None by default.
     * @param end The last index of the range to be copied into a new time series, None by default.
     * @param step The step size used to iterate through the time series, 1 by default.
     *
     * @result result The resulting time series.
     */
    @Pure
    @PythonName("slice_rows")
    fun sliceRows(
        start: Int? = null,
        end: Int? = null,
        step: Int = 1
    ) -> result: TimeSeries

    /**
     * Sort the columns of a `TimeSeries` with the given comparator and return a new `TimeSeries`.
     *
     * The comparator is a function that takes two columns `col1` and `col2` and
     * returns an integer:
     *
     * * If the function returns a negative number, `col1` will be ordered before `col2`.
     * * If the function returns a positive number, `col1` will be ordered after `col2`.
     * * If the function returns 0, the original order of `col1` and `col2` will be kept.
     *
     * If no comparator is given, the columns will be sorted alphabetically by their name.
     *
     * The original time series is not modified.
     *
     * @param comparator The function used to compare two columns.
     *
     * @result newTimeSeries A new time series with sorted columns.
     */
    @Pure
    @PythonName("sort_columns")
    fun sortColumns(
        comparator: (param1: Column<Any>, param2: Column<Any>) -> result1: Int
    ) -> newTimeSeries: TimeSeries

    /**
     * Return a new `TimeSeries` with the provided column transformed by calling the provided transformer.
     *
     * The original time series is not modified.
     *
     * @param name The name of the column to be transformed.
     * @param transformer The transformer to the given column
     *
     * @result result The time series with the transformed column.
     */
    @Pure
    @PythonName("transform_column")
    fun transformColumn(
        name: String,
        transformer: (param1: Row) -> result1: Any
    ) -> result: TimeSeries

    /**
     * Plot a lagplot for the target column.
     *
     * @param lag The amount of lag used to plot
     *
     * @result plot The plot as an image.
     *
     * @example
     * pipeline example {
     *     // from safeds.data.tabular.containers import TimeSeries
     *     // table = TimeSeries({"time":[1, 2], "target": [3, 4], "feature":[2,2]}, target_name= "target", time_name="time", feature_names=["feature"], )
     *     // image = table.plot_lagplot(lag = 1)
     * }
     */
    @Pure
    @PythonName("plot_lagplot")
    fun plotLagplot(
        lag: Int
    ) -> plot: Image

    /**
     * Plot the time series target or the given column(s) as line plot.
     *
     * The function will take the time column as the default value for y_column_name and the target column as the
     * default value for x_column_name.
     *
     * @param xColumnName The column name of the column to be plotted on the x-Axis, default is the time column.
     * @param yColumnName The column name of the column to be plotted on the y-Axis, default is the target column.
     *
     * @result plot The plot as an image.
     *
     * @example
     * pipeline example {
     *     // from safeds.data.tabular.containers import TimeSeries
     *     // table = TimeSeries({"time":[1, 2], "target": [3, 4], "feature":[2,2]}, target_name= "target", time_name="time", feature_names=["feature"], )
     *     // image = table.plot_lineplot()
     * }
     */
    @Pure
    @PythonName("plot_lineplot")
    fun plotLineplot(
        @PythonName("x_column_name") xColumnName: String? = null,
        @PythonName("y_column_name") yColumnName: String? = null
    ) -> plot: Image

    /**
     * Plot the time series target or the given column(s) as scatter plot.
     *
     * The function will take the time column as the default value for x_column_name and the target column as the
     * default value for y_column_name.
     *
     * @param xColumnName The column name of the column to be plotted on the x-Axis.
     * @param yColumnName The column name of the column to be plotted on the y-Axis.
     *
     * @result plot The plot as an image.
     *
     * @example
     * pipeline example {
     * }
     */
    @Pure
    @PythonName("plot_scatterplot")
    fun plotScatterplot(
        @PythonName("x_column_name") xColumnName: String? = null,
        @PythonName("y_column_name") yColumnName: String? = null
    ) -> plot: Image

    /**
     * Split the table into two new tables.
     *
     * The original time series is not modified.
     *
     * @param percentageInFirst The desired size of the first time series in percentage to the given time series; must be between 0 and 1.
     *
     * @result result A tuple containing the two resulting time series. The first time series has the specified size, the second time series
     * contains the rest of the data.
     *
     * @example
     * pipeline example {
     *     // from safeds.data.tabular.containers import TimeSeries
     *     // time_series = TimeSeries({"time":[0, 1, 2, 3, 4], "temperature": [10, 15, 20, 25, 30], "sales": [54, 74, 90, 206, 210]}, time_name="time", target_name="sales")
     *     // slices = time_series.split_rows(0.4)
     *     // slices[0]
     *     // slices[1]
     * }
     */
    @Pure
    @PythonName("split_rows")
    fun splitRows(
        @PythonName("percentage_in_first") percentageInFirst: Float
    ) -> (result1: TimeSeries, result2: TimeSeries)

    /**
     * Plot the given time series targets along the time on the x-axis.
     *
     * @param timeSeries A list of time series to be plotted.
     *
     * @result plot A plot with all the time series targets plotted by the time on the x-axis.
     */
    @Pure
    @PythonName("plot_compare_time_series")
    fun plotCompareTimeSeries(
        @PythonName("time_series") timeSeries: List<TimeSeries>
    ) -> plot: Image
}
