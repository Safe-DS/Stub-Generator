# serializer version: 1
# name: test_abstract_creation
  '''
  @PythonModule("test_package.abstract_module")
  package testPackage.abstractModule
  
  from abc import ABC
  from abc import abstractmethod
  
  class AbstractModuleClass {
  	@PythonName("abstract_property_method") attr abstractPropertyMethod: union<Float, Int>
  
  	// TODO Result type information missing.
  	@Pure
  	@PythonName("abstract_method")
  	fun abstractMethod()
  
  	@Pure
  	@PythonName("abstract_method_params")
  	fun abstractMethodParams(
  		@PythonName("param_1") param1: Int,
  		@PythonName("param_2") param2: Boolean = false
  	) -> result1: List<String>
  
  	// TODO Result type information missing.
  	@Pure
  	@PythonName("abstract_static_method")
  	static fun abstractStaticMethod()
  
  	@Pure
  	@PythonName("abstract_static_method_params")
  	static fun abstractStaticMethodParams(
  		param: Float
  	) -> result1: Boolean
  }
  
  '''
# ---
# name: test_class_attribute_creation
  '''
  @PythonModule("test_package.attribute_module")
  package testPackage.attributeModule
  
  class AttributesClassA()
  
  class AttributesClassB() {
  	@PythonName("type_hint_public")
  	static attr typeHintPublic: Int
  	@PythonName("no_type_hint_public")
  	static attr noTypeHintPublic: Int
  	@PythonName("object_attr")
  	static attr objectAttr: AttributesClassA
  	// TODO Safe-DS does not support tuple types.
  	@PythonName("tuple_attr_1")
  	static attr tupleAttr1: Tuple<Any>
  	// TODO Safe-DS does not support tuple types.
  	@PythonName("tuple_attr_2")
  	static attr tupleAttr2: Tuple<union<Int, String>>
  	// TODO Safe-DS does not support tuple types.
  	@PythonName("tuple_attr_3")
  	static attr tupleAttr3: Tuple<String, Int>
  	@PythonName("list_attr_1")
  	static attr listAttr1: List<Any>
  	@PythonName("list_attr_2")
  	static attr listAttr2: List<union<AttributesClassA, String>>
  	// TODO List type has to many type arguments.
  	@PythonName("list_attr_3")
  	static attr listAttr3: List<String, AttributesClassA>
  	// TODO List type has to many type arguments.
  	@PythonName("list_attr_4")
  	static attr listAttr4: List<String, union<AttributesClassA, Int>>
  	@PythonName("dict_attr_1")
  	static attr dictAttr1: Map<Any, Any>
  	@PythonName("dict_attr_2")
  	static attr dictAttr2: Map<String, Int>
  	@PythonName("dict_attr_3")
  	static attr dictAttr3: Map<union<Int, String>, AttributesClassA?>
  	@PythonName("bool_attr")
  	static attr boolAttr: Boolean
  	@PythonName("none_attr")
  	static attr noneAttr: Nothing?
  	@PythonName("flaot_attr")
  	static attr flaotAttr: Float
  	@PythonName("int_or_bool_attr")
  	static attr intOrBoolAttr: union<Boolean, Int>
  	@PythonName("str_attr_with_none_value")
  	static attr strAttrWithNoneValue: String
  	@PythonName("multi_attr_1")
  	static attr multiAttr1: Int
  	@PythonName("multi_attr_3")
  	static attr multiAttr3: List<String>
  	@PythonName("multi_attr_5")
  	static attr multiAttr5: String
  	@PythonName("multi_attr_6")
  	static attr multiAttr6: String
  	@PythonName("multi_attr_7")
  	static attr multiAttr7: String
  	@PythonName("multi_attr_8")
  	static attr multiAttr8: String
  	@PythonName("init_attr")
  	attr initAttr: Boolean
  }
  
  '''
# ---
# name: test_class_creation
  '''
  @PythonModule("test_package.class_module")
  package testPackage.classModule
  
  class ClassModuleEmptyClassA()
  
  class ClassModuleClassB(
  	a: Int,
  	b: ClassModuleEmptyClassA?
  ) sub ClassModuleEmptyClassA {
  	// TODO Result type information missing.
  	@Pure
  	fun f()
  }
  
  // TODO Safe-DS does not support multiple inheritance.
  class ClassModuleClassC() sub ClassModuleEmptyClassA, ClassModuleClassB {
  	@PythonName("attr_1")
  	static attr attr1: Int
  	@PythonName("attr_2")
  	static attr attr2: Int
  
  	// TODO Result type information missing.
  	@Pure
  	fun f1()
  }
  
  class ClassModuleClassD() {
  	class ClassModuleNestedClassE() {
  		@PythonName("nested_attr_1")
  		static attr nestedAttr1: Nothing?
  
  		@PythonName("_ClassModulePrivateDoubleNestedClassF")
  		class ClassModulePrivateDoubleNestedClassF()
  
  		// TODO Result type information missing.
  		@Pure
  		@PythonName("class_e_func")
  		fun classEFunc()
  	}
  }
  
  '''
# ---
# name: test_enum_creation
  '''
  @PythonModule("test_package.enum_module")
  package testPackage.enumModule
  
  from another_path.another_module import AnotherClass as _AcImportAlias
  
  enum _ReexportedEmptyEnum
  
  enum EnumTest {
  	ONE
  	TWO
  	THREE
  	FOUR
  	FIVE
  	SIX
  	SEVEN
  	EIGHT
  	NINE
  }
  
  enum EnumTest2 {
  	TEN
  }
  
  enum EnumTest3 {
  	ELEVEN
  }
  
  enum EmptyEnum
  
  '''
# ---
# name: test_function_creation
  '''
  @PythonModule("test_package.function_module")
  package testPackage.functionModule
  
  from typing import Callable
  
  // TODO Result type information missing.
  @Pure
  @PythonName("public_no_params_no_result")
  fun publicNoParamsNoResult()
  
  // TODO Result type information missing.
  @Pure
  fun params(
  	i: Int,
  	`union`: union<Boolean, Int>,
  	lst: List<Int>,
  	obj: FunctionModuleClassA
  )
  
  // TODO List type has to many type arguments.
  // TODO Result type information missing.
  // TODO Safe-DS does not support tuple types.
  @Pure
  @PythonName("illegal_params")
  fun illegalParams(
  	lst: List<Int, String>,
  	@PythonName("lst_2") lst2: List<Int, String, Int>,
  	tpl: Tuple<Int, String, Boolean, Int>,
  	`_`: Int = String
  )
  
  // TODO Result type information missing.
  @Pure
  @PythonName("special_params")
  fun specialParams(
  	@PythonName("none_union") noneUnion: Nothing?,
  	@PythonName("none_bool_union") noneBoolUnion: Boolean?,
  	@PythonName("bool_none_union") boolNoneUnion: Boolean?,
  	@PythonName("none_bool_none_union") noneBoolNoneUnion: Boolean?,
  	@PythonName("none_bool_int_union") noneBoolIntUnion: union<Boolean, Int, Nothing?>,
  	@PythonName("none_none_bool_none_union") noneNoneBoolNoneUnion: Boolean?,
  	@PythonName("none_list_union_none_none") noneListUnionNoneNone: List<Nothing?>?,
  	none: Nothing?
  )
  
  // TODO Result type information missing.
  // TODO Safe-DS does not support required but name only parameter assignments.
  // TODO Some parameter have no type information.
  @Pure
  @PythonName("param_position")
  fun paramPosition(
  	self,
  	a,
  	b: Boolean,
  	c: Int = 1,
  	d,
  	e: Int = 1
  )
  
  // TODO Result type information missing.
  // TODO Safe-DS does not support optional but position only parameter assignments.
  // TODO Some parameter have no type information.
  @Pure
  @PythonName("opt_pos_only")
  fun optPosOnly(
  	required,
  	optional: Int = 1
  )
  
  // TODO Result type information missing.
  // TODO Safe-DS does not support required but name only parameter assignments.
  // TODO Some parameter have no type information.
  @Pure
  @PythonName("req_name_only")
  fun reqNameOnly(
  	required,
  	optional: Int = 1
  )
  
  // TODO Result type information missing.
  // TODO Safe-DS does not support variadic parameters.
  @Pure
  fun arg(
  	args: List<Any>,
  	kwargs: Map<String, Any>
  )
  
  // TODO Result type information missing.
  // TODO Safe-DS does not support variadic parameters.
  @Pure
  @PythonName("args_type")
  fun argsType(
  	args: List<Int>,
  	kwargs: Map<String, Int>
  )
  
  @Pure
  @PythonName("one_result")
  fun oneResult() -> result1: Int
  
  @Pure
  @PythonName("multiple_results")
  fun multipleResults() -> (result1: String, result2: Int, result3: Boolean, result4: FunctionModuleClassA)
  
  @Pure
  @PythonName("callable_type")
  fun callableType(
  	param: (a: String) -> (b: Int, c: String)
  ) -> result1: (a: Int, b: Int) -> c: Int
  
  class FunctionModuleClassA()
  
  // TODO Some parameter have no type information.
  class FunctionModuleClassB(
  	@PythonName("init_param") initParam
  ) {
  	class FunctionModuleClassC() {
  		class FunctionModuleClassD()
  
  		@Pure
  		@PythonName("nested_class_function")
  		fun nestedClassFunction(
  			param1: Int
  		) -> result1: Boolean
  	}
  
  	@Pure
  	@PythonName("instance_method")
  	fun instanceMethod(
  		a: FunctionModuleClassA
  	) -> result1: FunctionModuleClassA
  
  	// TODO Result type information missing.
  	@Pure
  	@PythonName("static_method")
  	static fun staticMethod()
  
  	// TODO Result type information missing.
  	@Pure
  	@PythonName("static_method_params")
  	static fun staticMethodParams(
  		@PythonName("param_1") param1: Int
  	)
  
  	// TODO Result type information missing.
  	// TODO Safe-DS does not support class methods.
  	@Pure
  	@PythonName("class_method")
  	static fun classMethod()
  
  	// TODO Safe-DS does not support class methods.
  	@Pure
  	@PythonName("class_method_params")
  	static fun classMethodParams(
  		@PythonName("param_1") param1: Int
  	) -> result1: Boolean
  }
  
  class FunctionModulePropertiesClass() {
  	@PythonName("property_function") attr propertyFunction
  	@PythonName("property_function_params") attr propertyFunctionParams: String
  	@PythonName("property_function_infer") attr propertyFunctionInfer: String
  }
  
  '''
# ---
# name: test_import_creation
  '''
  @PythonModule("test_package.import_module")
  package testPackage.importModule
  
  import mypy as `static`
  
  from math import *
  
  '''
# ---
# name: test_type_inference
  '''
  @PythonModule("test_package.infer_types_module")
  package testPackage.inferTypesModule
  
  class InferMyTypes(
  	@PythonName("init_param") initParam: Int = 1
  ) {
  	@PythonName("infer_attr")
  	static attr inferAttr: Int
  	// TODO Attribute has no type information.
  	@PythonName("init_infer")
  	attr initInfer
  
  	@Pure
  	@PythonName("infer_function")
  	static fun inferFunction(
  		@PythonName("infer_param") inferParam: Int = 1,
  		@PythonName("infer_param_2") inferParam2: Int = Something
  	) -> (result1: InferMyTypes, result2: ModuleClass, result3: Nothing?, result4: Boolean, result5: Float, result6: Int, result7: String)
  }
  
  '''
# ---
# name: test_variance_creation
  '''
  @PythonModule("test_package.variance_module")
  package testPackage.varianceModule
  
  from typing import Generic
  from typing import TypeVar
  from typing import Literal
  
  class A()
  
  class VarianceClassAll<out TCo, in TCon, TIn>() where {
  	TCo sub String,
  	TCon super A
  }
  
  class VarianceClassOnlyInvariance<TIn>()
  
  '''
# ---
